// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package models

import (
	"encoding/json"
	"fmt"
	"regexp"
	"time"

	"github.com/google/uuid"
)

// Domain event carrying payload, context, and metadata.
type EventJson struct {
	// Optional URI of the affected entity.
	AffectedEntityUri *string `json:"affected_entity_uri,omitempty" yaml:"affected_entity_uri,omitempty" mapstructure:"affected_entity_uri,omitempty"`

	// Processing context for consumers (arbitrary key/value map).
	Context *map[string]interface{} `json:"context,omitempty" yaml:"context,omitempty" mapstructure:"context,omitempty"`

	// Optional URI to external context.
	ContextUri *string `json:"context_uri,omitempty" yaml:"context_uri,omitempty" mapstructure:"context_uri,omitempty"`

	// Identifier of the creator/producer.
	CreatedBy string `json:"created_by" yaml:"created_by" mapstructure:"created_by"`

	// Logical source of the event.
	EventSource string `json:"event_source" yaml:"event_source" mapstructure:"event_source"`

	// Optional URI describing the event source.
	EventSourceUri *string `json:"event_source_uri,omitempty" yaml:"event_source_uri,omitempty" mapstructure:"event_source_uri,omitempty"`

	// Event type.
	EventType string `json:"event_type" yaml:"event_type" mapstructure:"event_type"`

	// Unique identifier for the event.
	Id uuid.UUID `json:"id" yaml:"id" mapstructure:"id"`

	// MD5 hash of the canonical event representation.
	Md5Hash string `json:"md5_hash" yaml:"md5_hash" mapstructure:"md5_hash"`

	// Optional human-readable message.
	Message *string `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// Arbitrary string key/value metadata.
	Metadata map[string]string `json:"metadata" yaml:"metadata" mapstructure:"metadata"`

	// Optional owner id.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// JSON body of the event (arbitrary key/value map).
	Payload *map[string]interface{} `json:"payload,omitempty" yaml:"payload,omitempty" mapstructure:"payload,omitempty"`

	// Optional URI to an external payload.
	PayloadUri *string `json:"payload_uri,omitempty" yaml:"payload_uri,omitempty" mapstructure:"payload_uri,omitempty"`

	// Upstream request identifier.
	RequestId uuid.UUID `json:"request_id" yaml:"request_id" mapstructure:"request_id"`

	// Correlation/session identifier.
	SessionId uuid.UUID `json:"session_id" yaml:"session_id" mapstructure:"session_id"`

	// Optional string key/value tags.
	Tags *map[string]string `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Tenant identifier.
	TenantId uuid.UUID `json:"tenant_id" yaml:"tenant_id" mapstructure:"tenant_id"`

	// Event timestamp.
	Timestamp time.Time `json:"timestamp" yaml:"timestamp" mapstructure:"timestamp"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EventJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["created_by"]; raw != nil && !ok {
		return fmt.Errorf("field created_by in EventJson: required")
	}
	if _, ok := raw["event_source"]; raw != nil && !ok {
		return fmt.Errorf("field event_source in EventJson: required")
	}
	if _, ok := raw["event_type"]; raw != nil && !ok {
		return fmt.Errorf("field event_type in EventJson: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in EventJson: required")
	}
	if _, ok := raw["md5_hash"]; raw != nil && !ok {
		return fmt.Errorf("field md5_hash in EventJson: required")
	}
	if _, ok := raw["metadata"]; raw != nil && !ok {
		return fmt.Errorf("field metadata in EventJson: required")
	}
	if _, ok := raw["request_id"]; raw != nil && !ok {
		return fmt.Errorf("field request_id in EventJson: required")
	}
	if _, ok := raw["session_id"]; raw != nil && !ok {
		return fmt.Errorf("field session_id in EventJson: required")
	}
	if _, ok := raw["tenant_id"]; raw != nil && !ok {
		return fmt.Errorf("field tenant_id in EventJson: required")
	}
	if _, ok := raw["timestamp"]; raw != nil && !ok {
		return fmt.Errorf("field timestamp in EventJson: required")
	}
	type Plain EventJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[A-Fa-f0-9]{32}$`, string(plain.Md5Hash)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Md5Hash", `^[A-Fa-f0-9]{32}$`)
	}
	*j = EventJson(plain)
	return nil
}
